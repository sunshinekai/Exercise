/*
选择题

1.
一台主机要实现通过局域网与另一个局域网通信，需要做的工作是(C)
A 配置域名服务器
B 定义一条本机指向所在网络的路由
C 定义一条本机指向所在网络网关的路由
D 定义一条本机指向目标网络网关的路由

注：
如果主机想访问本地局域网外的某一网络，需要做两件事：
1、设置本机的默认网关
2、本地局域网默认网关上需要设置一条路由，用以完成本地局域网内的任一主机到目标局域网主机的路由工作。

2.
下列哪些功能使TCP准确可靠地从源设备到目地设备传输数据（D）
A 封装
B 流量控制
C 无连接服务
D 编号和定序

注：
TCP是用面向连接的传输保证数据准确可靠的传输，对数据封装成TCP报文，
每个TCP报文有编号，使用滑动窗口进行发送，接收ACK确认报文，以便接收端能够准确的恢复。

3.
下列关于地址转换的描述，错误的是（C）
A 地址转换解决了因特网地址短缺所面临问题
B 地址转换实现了对用户透明的网络外部地址的分配
C 使用地址转换后，对"IP包加长"，"快速转发"不会造成什么影响
D 地址转换内部主机提供一定的”隐私”

注：
网络地址转换(NAT)就是：路由器将私有地址转换为公有地址使数据包能够发到因特网上，
同时从因特网上接收数据包时，将公用地址转换为私有地址。NAT是作为一种解决IP地址短缺以避免保留IP地址困难的方案而流行起来的。
这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。
在一定程度上，NAT依赖于本地网络上的一台机器来初始化和路由器另一边的主机的任何连接，它可以阻止外部网络上的主机的恶意活动。
*/


/*
编程题

1.
链接：https://www.nowcoder.com/questionTerminal/95e35e7f6ad34821bc2958e37c08918b
NowCoder每天要给很多人发邮件。有一天他发现发错了邮件，把发给A的邮件发给了B，把发给B的邮件发给了A。
于是他就思考，要给n个人发邮件，在每个人仅收到1封邮件的情况下，有多少种情况是所有人都收到了错误的邮件？
即没有人收到属于自己的邮件。

示例：
输入
2
3
输出
1
2
*/


/*
解题思路：
用A、B、C……表示写着ｎ位友人名字的信封，a、b、c……表示ｎ份相应的写好的信纸。
把错装的总数为记作Der(n)。假设把a错装进B里了，包含着这个错误的一切错装法分两类：
1. b装入Ａ里，这时每种错装的其余部分都与A、B、a、b无关，应有Der(n－2)种错装法。
2. ｂ装入A、B之外的一个信封，这时的装信工作实际是把（除a之外的）n－1份信纸ｂ、ｃ……装入（除
B以外的）n－1个信封A、C……，显然这时装错的方法有Der(n－1)种。
总之在ａ装入B的错误之下，共有错装法Der(n－2)＋Der(n－1)种。
a装入C，装入Der……的n－2种错误之下，同样都有Der(n－1)＋Der(n－2)种错装法，因此Der(n)＝(n－1)
[Der(n－1)＋Der(n－2)]
*/

/*
#include <iostream>
#include <vector>

using namespace std;

long long error_count(int n)
{
	if (n == 1)
		return 0;
	else if (n == 2)
		return 1;
	return (n - 1) * (error_count(n - 1) + error_count(n - 2));
}

int main()
{
	int n;
	while (cin >> n)
	{
		long long ret = error_count(n);
		cout << ret << endl;
	}
	return 0;
}
*/

/*
2.
链接：https://www.nowcoder.com/questionTerminal/d83721575bd4418eae76c916483493de

广场上站着一支队伍，她们是来自全国各地的扭秧歌代表队，现在有她们的身高数据，请你帮忙找出身高依次递增的子序列。 
例如队伍的身高数据是（1、7、3、5、9、4、8），其中依次递增的子序列有（1、7），（1、3、5、9），（1、3、4、8）等，其中最长的长度为4。

示例：
输入
7
1 7 3 5 9 4 8
6
1 3 5 2 4 6
输出
4
4
*/


/*
解题思路：
动态规划的难点在于定义数组和创建“状态转移方程”。
1. 定义height来存储数据，f[i]为以height[i]结尾的元素的最长上升子序列元素个数，初始时将f所有内容
全部初始化成1，因为子序列中至少包含一个元素。
2. 定义"状态转移方程"
一开始先将f中的数据全部置为1，因为最小的子序列长度为1
然后对于每个height[i]，通过遍历height[0]~~height[i-1]之间的数据，如果在该区间中找到一个
height[j]比height[j]小的元素，开始比较f[j]+1和f[i]的大小，如果f[j]+1>f[j]则更新f[i],因此：
当height[i] > height[j]: f[i] = max(f[i], f[j]+1)
当height[i] <= height[j]：继续取下一个数据
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
	int n;
	while (cin >> n)
	{
		// 接受用户输入的数据
		vector<int> height(n, 0);
		for (int i = 0; i < n; i++)
			cin >> height[i];

		// f用来保存状态转移方程的结果，f[i]表示以height[i]结尾的最长上升子序列所包含元素的个数
		vector<int> f(n, 1);
		int result = 1;
		// 子序列中的数据一个一个增加
		for (int i = 1; i < n; i++)
		{
			// 从0开始统计到i位置，最长上升子序列长度
			for (int j = 0; j < i; j++)
			{
				if (height[i] > height[j])
					f[i] = max(f[i], f[j] + 1);
			}
			// 获取从0到i位置的最长子序列长度
			result = max(result, f[i]);
		}
		cout << result << endl;
	}
}