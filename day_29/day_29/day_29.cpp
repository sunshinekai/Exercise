/*
选择题

1.
X86体系结构在保护模式下中有三种地址，请问一下那种说法是正确的(C)
A 虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址
B 线性地址先经过分段机制映射到虚拟地址，然后虚拟地址通过分页机制映射到物理地址
C 虚拟地址先经过分页机制映射到线性地址，然后线性地址通过分段机制映射到物理地址
D 线性地址先经过分页机制映射到虚拟地址，然后虚拟地址通过分段机制映射到物理地址

实模式和保护模式是CPU的两种工作模式。一开始PC启动时CPU是工作在实模式下的，经过某种机制后，
CPU跳转到保护模式。其访问空间扩大了，要想从保护模式返回到实模式就只能重启。

当x86 CPU工作在保护模式时，可以使用全部32根地址线访问4GB的内存，
因为80386的所有通用寄存器都是32位的，所以用任何一个通用寄存器来间接寻址，不用分段就可以访问4G空间中任意的内存地址。

2.
对于Linux说法，下列说法正确的是（A）
A 线性访问内存非法时，当前线程会进入信号处理函数
B 用mv命令移动文件时，文件的修改时间会发生变化
C ulimit -c设置的是函数调用栈的大小
D malloc函数是应用程序向操作系统申请内存的接口

注：
对于B：用mv命令移动文件时，文件的修改时间不会发生变化
对于C：ulimit用于shell启动进程所占用的资源.-c size:设置core文件的最大值.单位:blocks
对于D：malloc是glibc里的库函数，它封装了一些向系统申请内存的系统调用
而且并不是每次使用malloc的时候都会向系统申请新的内存，所以D是错的

3.
如果系统的umask设置为244，创建一个新文件后，它的权限：（）
A --w-r--r--
B -r-xr--r--
C -r---w--w
D -r-x-wx-wx
注：
在Linux中r，w，x的值分别是 ： 4 2 1
文件的默认值是666
目录的默认值是777
新建一个文件所以是666-244=422

4.
程序出错在什么阶段（F）
int main(void)
{
	http://www.taobao.com
	cout << "welcome to taobao" << endl;
	return 0;
}

A 预处理阶段出错
B 编译阶段出错
C 汇编阶段出错
D 链接阶段出错
E 运行阶段出错
F 程序运行正常
注：
http相当于一个label，//www.taobao.com是注释，所以答案错误，可以运行

5.
有一个变量int a=0；两个线程同时进行+1操作，每个线程加100次，不加锁，最后a的值是（B）
A 200
B <=200
C >=200
D 都有可能

注：
两个线程分别记为线程1和线程2，i++相当于取出i的值，加1，再放回去
第一种极端情况：每次线程一取出i的值后CPU时间切换到线程二，线程二也取出i的值，取到的值和线程一相等，
线程二给i加一后放回去，线程一也将i加一后放回去，放回去的值也相等，
相当于两个线程都执行一次i++操作，i的值只增加1，这样操作100次i的值为100
第二种极端情况：线程一和线程二间隔操作，即线程一对i++操作完成，
把已经加一的数据放回去之后线程二再操作，轮流进行，最后每个线程都对i加了100次，i的值为200
*/



/*
编程题

1.
链接：https://www.nowcoder.com/questionTerminal/296c2c18037843a7b719cf4c9c0144e4?source=relative
给定一个全是正数的数组arr，定义一下arr的最小不可组成和的概念：
1，arr的所有非空子集中，把每个子集内的所有元素加起来会出现很多的值，其中最小的记为min，最大的记为max；
2，在区间[min,max]上，如果有一些正数不可以被arr某一个子集相加得到，那么这些正数中最小的那个，就是arr的最小不可组成和；
3，在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最小不可组成和；
举例： arr = {3,2,5} arr的min为2，max为10，在区间[2,10]上，4是不能被任何一个子集相加得到的值中最小的，所以4是arr的最小不可组成和； 
arr = {3,2,4} arr的min为2，max为9，在区间[2,9]上，8是不能被任何一个子集相加得到的值中最小的，所以8是arr的最小不可组成和； 
arr = {3,1,2} arr的min为1，max为6，在区间[2,6]上，任何数都可以被某一个子集相加得到，所以7是arr的最小不可组成和； 
请写函数返回arr的最小不可组成和。
*/

/*
用set存储数组中所有子集之和，用find逐次遍历
若找到则返回i，若未找到则返回i + 1
*/

class Solution {
public:
	/**
	*	正数数组中的最小不可组成和
	*	输入：正数数组arr
	*	返回：正数数组中的最小不可组成和
	*/
	int getFirstUnFormedNum(vector<int> arr, int len)
	{
		sort(arr.begin(), arr.end());
		set<int> s;
		vector<int> v;
		for (int i = 0; i < len; i++)
		{
			for (auto & e : s)
				v.push_back(arr[i] + e);
			for (auto & e : v)
				s.insert(e);
			s.insert(arr[i]);
			v.clear();
		}
		for (int i = arr[0];; i++)
		{
			if (s.find(i) == s.end())
				return i;
		}
	}
};



/*
2.
链接：https://www.nowcoder.com/questionTerminal/1d18c0841e64454cbc3afaea05e2f63c
居然有假币！ 现在猪肉涨了，但是农民的工资却不见涨啊，没钱怎么买猪肉啊。nowcoder这就去买猪肉，结果找来的零钱中有假币！！！可惜nowcoder
一不小心把它混进了一堆真币里面去了。只知道假币的重量比真币的质量要轻，给你一个天平（天平两端能容纳无限个硬币），
请用最快的时间把那个可恶的假币找出来。

输入：
3 
12
0

输出：
1
3
*/

/*
思路：平均分三份是最快的方法，两份进行称重（对比出三个的重量 ），后对最重的那份再次进行称重，
直到称重的个数不足2个时则结束，获得假币 如果无法平均分3分则余数要么是1要么是2，因为是要最多称几次，n=n/3+1
满足每次取最大 分称3份，取两份一样多的过秤，然后把三份中最多的那份继续分，直到硬币剩余0或1时截至
*/

#include <iostream>
using namespace std;
int main()
{
	int n;
	while (cin >> n)
	{
		int count = 0;
		if (n == 0)
			break;
		while (n > 1)
		{
			if (n % 3 == 0)
				n /= 3;
			else
				n = n / 3 + 1;
			count++;
		} 
		cout << count << endl;
	} 
	return 0;
}