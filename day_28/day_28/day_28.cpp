/*
选择题
1.
下面的程序执行输出几个hello(D)
#include<stdio.h>
#include <unistd.h>
int main() {
	fork();
	fork();
	fork();
	printf(“hello\n”);
	return 0;
}
A 3
B 4
C 6
D 8
注：fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，
也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。

fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：
1）在父进程中，fork返回新创建子进程的进程ID；
2）在子进程中，fork返回0；
3）如果出现错误，fork返回一个负值;

2.
下列进程调度算法中，（B）可能会出现进程长期得不到调度的情况。
A 非强占式静态优先权法
B 强占式静态优先权法
C 时间片轮转调度算法
D 非强占式动态优先权法
注：抢占式保证了高优先级的进程可以直接抢夺低优先级进程的资源，优先运行；
静态优先权是指：在进程运行前就已经分配了固定的优先权，在进程运行的过程中
不再对优先权进行调整，这样就导致了低优先级的进程一直得不到资源，即“饥饿”状态！
*/



/*
编程题

1.
链接：https://www.nowcoder.com/questionTerminal/b89b14a3b5a94e438b518311c5156366

给定一个长度不小于2的数组arr。 写一个函数调整arr，使arr中要么所有的偶数位上都是偶数，
要么所有的奇数位上都是奇数上。 
要求：如果数组长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1),
下标0,2,4,6...算作偶数位,下标1,3,5,7...算作奇数位，例如[1,2,3,4]调整为[2,1,4,3]即可
*/

/*
思路：在偶数位上寻找非偶数，在奇数位上寻找非奇数，两个数字进行位置互换即可
*/

class Solution {
public:
	void oddInOddEvenInEven(std::vector<int>& arr, int len) {
		long i = 0, j = 1;
		while (i < len && j < len)
		{
			if ((arr[i] % 2) == 0) 
			{ 
				i += 2; 
				continue; 
			}	//偶数位上寻找非偶数
			if ((arr[j] % 2) != 0) 
			{ 
				j += 2; 
				continue; 
			}	//奇数位上寻找非奇数
			swap(arr[i], arr[j]);
		}
	}
};



/*
2.
链接：https://www.nowcoder.com/questionTerminal/480d2b484e1f43af8ea8434770811b4a

老猴子辛苦了一辈子，给那群小猴子们留下了一笔巨大的财富――一大堆桃子。老猴子决定把这些桃子分给小猴子。
第一个猴子来了，它把桃子分成五堆，五堆一样多，但还多出一个。它把剩下的一个留给老猴子，自己拿走其中的一堆。
第二个猴子来了，它把桃子分成五堆，五堆一样多，但又多出一个。它把多出的一个留给老猴子，自己拿走其中的一堆。
后来的小猴子都如此照办。最后剩下的桃子全部留给老猴子。
这里有n只小猴子，请你写个程序计算一下在开始时至少有多少个桃子，以及最后老猴子最少能得到几个桃子。
*/

/*
思路：公式类推
因为每次分5堆都会多出来1个，所以我们借给猴子们4个，以致每次都可以刚好分成5堆 并且，每次给老猴子的桃
子都不在我们借出的那4个中，这样最后减掉4就可以得到结果。 假设最初由x个桃子，我们借给猴子4个，则此时
有x+4个， 第一个猴子得到（x+4）/5，剩余（x+4）（4/5）个 第二个猴子分完后剩余（x+4） (4/5)^2个 第三个
猴子分完后剩余（x+4） (4/5)^3个 依次类推，第n个猴子分完后剩余（x+4）（4/5）^n 要满足最后剩余的为整
数，并且x最小，则当 x+4=5^n时，满足要求；此时，x=5^n - 4; 老猴子得到的数量为：x+4）*（4/5）^n + n - 4
= 4^n + n - 4 最后的 +n是因为每个小猴子都会多出一个给老猴子，-4是还了借的4个
*/


#include <iostream>
#include <string>
#include <cmath>
int main()
{
	int n;
	while (std::cin >> n) 
	{
		if (n == 0) break;
		long total = pow(5, n) - 4;
		long left = pow(4, n) + n - 4;
		std::cout << total << " " << left << std::endl;
	}
	return 0;
}