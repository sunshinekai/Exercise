/*
选择题
1.
在具有 2n 个结点的完全二叉树中，叶子结点个数为(A)
A n
B n+1
C n-1
D n/2

注：完全二叉树是指除最后一层外，每一层上的结点数均达到最大值，在最后一层上只缺少右边的若干结点。根据完全二叉树性质，如果共 2n 个结点，
从根结点开始按层序用自然数 1 ， 2 ，…， 2n 给结点编号，则编号为 n 的结点左子结点编号为 2n ，因此叶子结点编号为 n+1,n+2, … ,2n 。
故叶子结点个数为 n ，本题答案为 A 选项。

2.
下述二叉树中,哪一种满足性质:从任一结点出发到根的路径上所经过的结点序列按其关键字有序(D)
A 二叉排序树
B 哈夫曼树
C AVL树
D 堆

Huffman树的权值全部在叶子上，那些分支的权值仅仅供构造算法使用的，其实是没有权值的
至于堆有两种，最小堆和最大堆，最小堆就是递增有序，最大堆就是递减有序，问题只是问有序，不一定是降序
至于二叉排序树和AVL树肯定不能满足这个条件，只是满足中序有序
*/



/*
编程题

1.
链接：https://www.nowcoder.com/practice/5a0a2c7e431e4fbbbb1ff32ac6e8dfa0?tpId=85&&tqId=29848&rp=1&ru=/activity/oj&qru=/ta/2017test/question-ranking

洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。 现在需要洗2n张牌，
从上到下依次是第1张，第2张，第3张一直到第2n张。首先，我们把这2n张牌分成两堆，
左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。接着就开始洗牌的过程，
先放下右手的最后一张牌，再放下左手的最后一张牌，接着放下右手的倒数第二张牌，
再放下左手的倒数第二张牌，直到最后放下左手的第一张牌。接着把牌合并起来就可以了。
例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，左手拿着1,2,3；
右手拿着4,5,6。在洗牌过程中按顺序放下了6,3,5,2,4,1。把这六张牌再次合成一组牌之后，
我们按照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。
现在给出一个原始牌组，请输出这副牌洗牌k次之后从上往下的序列。
输入
3
3 1
1
2
3
4
5
6
3 2
1
2
3
4
5
6
2 2
1
1
1
1

输出
1 4 2 5 3 6
1 5 4 3 2 6
1 1 1 1
*/

/*
本题题目的意思是模拟洗牌过程，牌被分成两组，且每组数量相等，然后每组牌从最后一个牌交叉排列，最
后再把排列逆序就是一次洗牌的过程，K次需要重复K次这样的过程。

思路：
每次读取一个数之后，算出他经过k次洗牌后的位置，只用一个长度为2n数组用来输出
根据当前数的位置，可以算出经过一次洗牌后的位置
如果当前数小于等于n（即在左手），则他下次出现的位置是 2 * 当前位置
与之对应的当前位置 + n（即在右手）的牌, 则他下次出现的位置是 2 * 当前位置 + 1
*/

#include<iostream>
#include<vector>

using namespace std;
int main()
{
	int T, n, k;
	cin >> T;
	while (T--)
	{
		cin >> n >> k;
		int num = 2 * n;
		vector<int> table(num);
		for (int i = 0; i < num; ++i)
			cin >> table[i];
		//洗k次牌
		while (k--)
		{
			vector<int> n1(table.begin(), table.end());
			for (int i = 0; i < n; ++i)
			{
				//如果当前数小于等于n（即在左手），则他下次出现的位置是 2*当前位置
				//与之对应的当前位置 + n（即在右手）的牌,则他下次出现的位置是 2*当前位置 + 1
				table[2 * i] = n1[i];
				table[2 * i + 1] = n1[i + n];
			}
		} 
		for(int i = 0; i < num - 1; ++i)
			cout << table[i] << " ";
		cout << table[num - 1] << endl;
	} 
	return 0;
}



/*
2.
链接：https://www.nowcoder.com/practice/eaf5b886bd6645dd9cfb5406f3753e15?tpId=37&&tqId=21287&rp=1&ru=/activity/oj&qru=/ta/huawei/question-ranking

MP3 Player因为屏幕较小，显示歌曲列表的时候每屏只能显示几首歌曲，用户要通过上下键才能浏览所有的歌曲。为了简化处理，假设每屏只能显示4首歌曲，光标初始的位置为第1首歌。

现在要实现通过上下键控制光标移动来浏览歌曲列表，控制逻辑如下：
1.歌曲总数<=4的时候，不需要翻页，只是挪动光标位置。
光标在第一首歌曲上时，按Up键光标挪到最后一首歌曲；光标在最后一首歌曲时，按Down键光标挪到第一首歌曲。
其他情况下用户按Up键，光标挪到上一首歌曲；用户按Down键，光标挪到下一首歌曲。

2. 歌曲总数大于4的时候（以一共有10首歌为例）：
特殊翻页：屏幕显示的是第一页（即显示第1 C 4首）时，光标在第一首歌曲上，
用户按Up键后，屏幕要显示最后一页（即显示第7-10首歌），同时光标放到最后一首歌上。
同样的，屏幕显示最后一页时，光标在最后一首歌曲上，用户按Down键，屏幕要显示第一页，光标挪到第一首歌上。
一般翻页：屏幕显示的不是第一页时，光标在当前屏幕显示的第一首歌曲时，用户按Up键后，
屏幕从当前歌曲的上一首开始显示，光标也挪到上一首歌曲。光标当前屏幕的最后一首歌时的Down键处理也类似。

其他情况，不用翻页，只是挪动光标就行。

输入
10
UUUU

输出
7 8 9 10
7
*/

/*
本题的意思是第一行输入歌曲数量，第二行输入指令，最后需要显式的输出也为两行，第一行为当前歌曲所
在的列表，第二行为光标所指向的歌曲。
思路：
本题比较简单，通过解析指令，进行移动即可，分两种情况，歌曲数目不大于4和大于4的情况。
*/

#include <iostream>
#include <string>
using namespace std;
int main(){
	//歌曲数量
	int n;
	//命令
	string order;
	while (cin >> n >> order)
	{
		//将n首歌曲编号1：n , num为光标当前所在歌曲的编号,first为当前屏幕显示页的第一首歌曲的编号
		int num = 1, first = 1;
		if (n <= 4) //歌曲总数不超过4时，所有歌曲一页即可显示完，不需翻页，first始终不变
		{
			for (int i = 0; i < order.size(); i++)
			{
				if (num == 1 && order[i] == 'U')
					num = n;
				else if (num == n && order[i] == 'D')
					num = 1;
				else if (order[i] == 'U')
					num--;
				else
					num++;
			}

			for(int i = 1; i <= n - 1; i++)
				cout << i << ' ';
			cout << n << endl;
			cout << num << endl;
		} 
		else //歌曲总数大于4时，显示完全所有歌曲需要翻页，屏幕总是显示4首歌曲
		{
			for (int i = 0; i < order.size(); i++)
			{
				if (first == 1 && num == 1 && order[i] == 'U')
				{
					first = n - 3; num = n;
				} //特殊翻页1
				else if (first == n - 3 && num == n && order[i] == 'D')
				{
					first = 1; num = 1;
				} //特殊翻页2
				else if (first != 1 && num == first && order[i] == 'U')
				{
					first--; num--;
				} //一般翻页1
				else if (first != n - 3 && num == first + 3 && order[i] == 'D')
				{
					first++; num++;
				} //一般翻页2
				else if (order[i] == 'U')
					num--; //其他情况1
				else
					num++; //其他情况2
			} 
			for(int i = first; i < first + 3; i++)
				cout << i << ' ';
			cout << first + 3 << endl;
			cout << num << endl;
		}
	} 
	return 0;
}