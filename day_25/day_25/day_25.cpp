/*
选择题

1.
一进程刚获得三个主存块的使用权，若该进程访问页面的次序是｛1321215123｝，采用LRU算法时，缺页数
是(C)次。
A 3
B 4
C 5
D 6

注：
此题是考查操作系统的进程页面管理调度算法问题。如果采用先进先出的算法，
开始时由于没有任何页面所以前三次都发生了缺页中断，依次三次由于页面已在主存中，
所以没有发生缺页，到了第七次之时由于页面未在主存中所以缺页一次，
换出了页面1，到了八次，由于页面1刚换出，所以缺页一次，换出了页面3，
到了最后一次访问时，由于页面3被换出，所以又缺页一次，所以总共发生了6次缺页。
如果采用LRU时，与前面不同的是在第七次发生缺页时，换出来的是页面3，
在最后一次由于页面3没有在主存中，所以一次缺页，这样就比前种方法少了第八的缺页中断，所以为5次。

2.
以下关于多线程的叙述错误的是(C)
A 线程同步的方法包括使用临界区，互斥量，信号量等
B 两个线程同时对简单类型全局变量进行写操作也需要互斥
C 实现可重入函数时，对自动变量也要用互斥量加以保护
D 可重入函数不可以调用不可重入函数

注：
自动变量外部不可见，不需要互斥量保护

3.
关于子进程和父进程的说法，下面哪一个是正确的（D）
A 一个父进程可以创建若干个子进程，一个子进程可以从属于若干个父进程
B 父进程被撤销时，其所有子进程也被相应撤消
C 子进程被撤销时，其从属的父进程也被撤销
D 一个进程可以没有父进程或子进程

注：
允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。
子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源
归还给父进程。僵尸进程与孤儿进程都是父进程被撤销时，子进程没有被撤销的情况。
*/


/*
编程题

1.
链接：https://www.nowcoder.com/questionTerminal/34f17d5f2a8240bea661a23ec095a062

星际战争开展了100年之后，NowCoder终于破译了外星人的密码！他们的密码是一串整数
，通过一张表里的信息映射成最终4位密码。表的规则是：n对应的值是矩阵X的n次方的左上角，如果这个数不足4位则用0填充，
如果大于4位的则只输出最后4位。
|1 1|^n => |Xn ..|
|1 0|      |.. ..|
例如n=2时，
|1 1|^2 => |1 1| * |1 1| => |2 1|
|1 0|      |1 0|   |1 0|    |1 1|
即2对应的数是“0002”。

输入
6
18 15 21 13 25 27

5
1 10 100 1000 10000

输出
418109877711037713937811

00010089410135017501
*/

/*
思路：
这个题目首先需要明确矩阵是固定的，其次是矩阵相乘的方法
矩阵相乘 | a1 a2 | *| c1 c2 | = | a1c1 + a2d1 a1c2 + a2d2 | | b1 b2 | | d1 d2 | | b1c1 + b2d1 b1d2 + b2d2 |
矩阵是
| 1 1 | ^ 2 = | 1 1 | *| 1 1 |= | 2 1 | | 1 0 | | 1 0 | | 1 0 | | 1 1 | n的取值：1 2 3 4 5 6 ....左上角值：1 2 3 5 8 13 ....
是一个变式的斐波那契
初始化斐波那契数列，每次获取对应数据，打印最后4位即可
*/

#include <iostream>
#include <vector>
std::vector<int> a = { 1, 1 };
void data_init()
{
	int i;
	for (i = 2; i<10005; i++)
		a.push_back((a[i - 1] + a[i - 2]) % 10000);
}

int main()
{
	int n, t;
	data_init();
	while (std::cin >> n)
	{
		while (n--)
		{
			std::cin >> t;
			printf("%04d", a[t]);
		}
		printf("\n");
	}
	return 0;
}



/*
2.
链接：https://www.nowcoder.com/questionTerminal/e2422543519249f292d8435394ab82fe
数根可以通过把一个数的各个位上的数字加起来得到。如果得到的数是一位数，那么这个数就是数根；
如果结果是两位数或者包括更多位的数字，那么再把这些数字加起来。如此进行下去，直到得到是一位数为止。
比如，对于24 来说，把2 和4 相加得到6，由于6 是一位数，因此6 是24 的数根。
再比如39，把3 和9 加起来得到12，由于12 不是一位数，因此还得把1 和2 加起来，最后得到3，这是一个一位数，因此3 是39 的数根。
现在给你一个正整数，输出它的数根。
*/

/*
1. 接收字符串得到各个数字，并且每位求和（为了得到的数字不大于99）
2. 循环对大于9的数字进行对10取余和整除操作，将两个结果进行相加得到树根
*/

#include <iostream>
#include <string>

using namespace std;

int numRoot(int n)
{
	int tmp = 0;
	while (n)
	{
		int ret = n % 10;
		tmp += ret;
		n /= 10;
	} 
	return tmp;
} 

int main()
{
	string str;
	while (cin >> str)
	{
		int n = 0;
		for (auto & e : str)
			n += e - '0';
		while (n > 9)
			n = numRoot(n);
		cout << n << endl;
	} 
	return 0;
}